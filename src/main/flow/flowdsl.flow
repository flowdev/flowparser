version 0.1

flow ParseFlowFile {
  [String]-> (ParserManager) [FlowFile]-> ;
  parserManager() subOut [ParserData]-> (ReadTextFile) -> parseFlowFile(ParseAll) -> subIn parserManager() ;

  parseFlowFile() semOut [ParserData]-> (CreateFlowFileData) -> semIn parseFlowFile() ;
  parseFlowFile() subOut.0 [ParserData]-> (Version) -> subIn parseFlowFile() ;
  parseFlowFile() subOut.1 [ParserData]-> parseFlows(ParseMultiple1) -> subIn parseFlowFile() ;
  parseFlowFile() subOut.2 [ParserData]-> (ParseEof) -> subIn parseFlowFile() ;

  parseFlows() subOut [ParserData]-> (Flow) -> subIn parseFlows() ;
}

flow Version {
  [ParserData]-> parseVersion(ParseAll) -> ;
  parseVersion() semOut [ParserData]-> (CreateVersion) -> semIn parseVersion() ;

  parseVersion() subOut.0 [ParserData]-> vers(ParseLiteral("version")) -> subIn parseVersion() ;
  parseVersion() subOut.1 [ParserData]-> aspc(ParseSpace(false)) -> subIn parseVersion() ;
  parseVersion() subOut.2 [ParserData]-> political(ParseNatural) -> subIn parseVersion() ;
  parseVersion() subOut.3 [ParserData]-> dot(ParseLiteral(".")) -> subIn parseVersion() ;
  parseVersion() subOut.4 [ParserData]-> major(ParseNatural) -> subIn parseVersion() ;
  parseVersion() subOut.5 [ParserData]-> spcComm(SpaceComment) -> subIn parseVersion() ;
}

flow Flow {
  [ParserData]-> parseFlow(ParseAll) -> ;
  parseFlow() semOut [ParserData]-> (CreateFlow) -> semIn parseFlow() ;

  parseFlow() subOut.0 [ParserData]-> flow(ParseLiteral("flow")) -> subIn parseFlow() ;
  parseFlow() subOut.1 [ParserData]-> space(ParseSpace(false)) -> subIn parseFlow() ;
  parseFlow() subOut.2 [ParserData]-> bigIdent(ParseBigIdent) -> subIn parseFlow() ;
  parseFlow() subOut.3 [ParserData]-> spcComm1(SpaceComment) -> subIn parseFlow() ;
  parseFlow() subOut.4 [ParserData]-> openFlow(ParseLiteral("{")) -> subIn parseFlow() ;
  parseFlow() subOut.5 [ParserData]-> spcComm2(SpaceComment) -> subIn parseFlow() ;
  parseFlow() subOut.6 [ParserData]-> (Connections) -> subIn parseFlow() ;
  parseFlow() subOut.7 [ParserData]-> closeFlow(ParseLiteral("}")) -> subIn parseFlow() ;
  parseFlow() subOut.8 [ParserData]-> spcComm3(SpaceComment) -> subIn parseFlow() ;
}


// -------------------------------------------------------------------------
// Flows for parsing (chains of) connetcions
//

flow Connections {
  [ParserData]-> connections(ParseMultiple1) -> ;
  connections() subOut [ParserData]-> chain(ParseAll) -> subIn connections() ;
  chain() semOut [ParserData]-> (CreateChain) -> semIn chain() ;

  chain() subOut.0 [ParserData]-> (ConnectionChainBegin) -> subIn.0 chain() ;
  chain() subOut.1 [ParserData]-> chainMid(ParseMultiple) -> subIn.1 chain() ;
  chain() subOut.2 [ParserData]-> chainEnd(ParseOptional) -> subIn.2 chain() ;
  chain() subOut.3 [ParserData]-> (StatementEnd) -> subIn.3 chain() ;

  chainMid() subOut [ParserData]-> (ConnectionChainMiddle) -> subIn chainMid() ;

  chainEnd() subOut [ParserData]-> (ConnectionChainEnd) -> subIn chainEnd() ;
}

flow ConnectionChainBegin {
  [ParserData]-> chainBeg(ParseAlternatives) -> ;

  chainBeg() subOut.0 [ParserData]-> chainBegMax(ParseAll) -> subIn.0 chainBeg() ;
  chainBeg() subOut.1 [ParserData]-> chainBegMin(ParseAll) -> subIn.1 chainBeg() ;

  chainBegMax() semOut [ParserData]-> (CreateChainBegMax) -> semIn chainBegMax() ;
  chainBegMax() subOut.0 [ParserData]-> opPortMax(ParseOptional) -> subIn.0 chainBegMax() ;
  chainBegMax() subOut.1 [ParserData]-> (ConnectionChainMid) -> subIn.1 chainBegMax() ;

  opPortMax() subOut [ParserData]-> portMax(Port) -> subIn opPortMax() ;

  chainBegMin() semOut [ParserData]-> (CreateChainBegMin) -> semIn chainBegMin() ;
  chainBegMin() subOut.0 [ParserData]-> (OperationNameParens) -> subIn.0 chainBegMin() ;
  chainBegMin() subOut.1 [ParserData]-> opPortMin(ParseOptional) -> subIn.1 chainBegMin() ;

  opPortMin() subOut [ParserData]-> portMin(Port) -> subIn opPortMin() ;
}

flow ConnectionChainMiddle {
  [ParserData]-> chainMid(ParseAll) -> ;
  chainMid() semOut [ParserData]-> (CreateChainMid) -> semIn chainMid() ;

  chainMid() subOut.0 [ParserData]-> (Arrow) -> subIn.0 chainMid() ;
  chainMid() subOut.1 [ParserData]-> (ConnectionPart) -> subIn.1 chainMid() ;
}

flow ConnectionChainEnd {
  [ParserData]-> chainEnd(ParseAll) -> ;
  chainEnd() semOut [ParserData]-> (CreateChainEnd) -> semIn chainEnd() ;

  chainEnd() subOut.0 [ParserData]-> (Arrow) -> subIn.0 chainEnd() ;
  chainEnd() subOut.1 [ParserData]-> opPort(OpPort) -> subIn.1 chainEnd() ;

  opPort() subOut [ParserData]-> (Port) -> subIn opPort() ;
}


// -------------------------------------------------------------------------
// Flows for parsing parts of connetcions
//

flow ConnectionPart {
  [ParserData]-> connPart(ParseAll) -> ;
  connPart() semOut [ParserData]-> (CreateConnectionPart) -> semIn connPart() ;

  connPart() subOut.0 [ParserData]-> opInPort(OpPortSpc) -> subIn.0 connPart() ;
  connPart() subOut.1 [ParserData]-> (OperationNameParens) -> subIn.1 connPart() ;
  connPart() subOut.2 [ParserData]-> opOutPort(OpPort) -> subIn.2 connPart() ;
}

flow OperationNameParens {
  [ParserData]-> opNameParens(ParseAll) -> ;
  opNameParens() semOut [ParserData]-> (CreateOperationNameParens) -> semIn opNameParens() ;

  opNameParens() subOut.0 [ParserData]-> opOpName(ParseOptional) -> subIn.0 opNameParens() ;
  opNameParens() subOut.1 [ParserData]-> openType(ParseLiteral("(")) -> subIn.1 opNameParens() ;
  opNameParens() subOut.2 [ParserData]-> spc1(OpSpc) -> subIn.2 opNameParens() ;
  opNameParens() subOut.3 [ParserData]-> opOpType(OpOperationType) -> subIn.3 opNameParens() ;
  opNameParens() subOut.4 [ParserData]-> closeType(ParseLiteral(")")) -> subIn.4 opNameParens() ;
  opNameParens() subOut.5 [ParserData]-> spc2(OpSpc) -> subIn.5 opNameParens() ;

  opOpName() subOut [ParserData]-> opName(ParseAll) -> subIn opOpName() ;
  opOpName() semOut [ParserData]-> (CreateOperationName) -> semIn opOpName() ;

  opName() subOut.0 [ParserData]-> smallIdent(SmallIdent) -> subIn.0 opName() ;
  opName() subOut.1 [ParserData]-> spc3(OpSpc) -> subIn.1 opName() ;
}

flow OpOperationType {
  [ParserData]-> opOpType(ParseOptional) -> ;
  opOpType() semOut [ParserData]-> (CreateOperationType) -> semIn opOpType() ;
  opOpType() subOut [ParserData]-> opType(ParseAll) -> subIn opOpType() ;

  opType() semOut [ParserData]-> (CreateOpType) -> semIn opType() ;

  opType() subOut.0 [ParserData]-> (BigIdent) -> subIn.0 opType() ;
  opType() subOut.1 [ParserData]-> (OpSpc) -> subIn.1 opType() ;
}

flow Arrow {
  [ParserData]-> arrow(ParseAll) -> ;
  arrow() semOut [ParserData]-> (CreateArrow) -> semIn arrow() ;

  arrow() subOut.0 [ParserData]-> spcCom1(SpaceComment) -> subIn.0 arrow() ;
  arrow() subOut.1 [ParserData]-> opType(ParseOptional) -> subIn.1 arrow() ;
  arrow() subOut.2 [ParserData]-> litArr(ParseLiteral("->")) -> subIn.2 arrow() ;
  arrow() subOut.3 [ParserData]-> spcCom1(SpaceComment) -> subIn.3 arrow() ;

  opType() subOut [ParserData]-> type(ParseAll) -> subIn opType() ;
  type() semOut [ParserData]-> (CreateArrowType) -> semIn type() ;

  type() subOut.0 [ParserData]-> openType(ParseLiteral("[")) -> subIn type() ;
  type() subOut.1 [ParserData]-> spc1(OpSpc) -> subIn type() ;
  type() subOut.2 [ParserData]-> typeName(BigIdent) -> subIn type() ;
  type() subOut.3 [ParserData]-> spc2(OpSpc) -> subIn type() ;
  type() subOut.4 [ParserData]-> openType(ParseLiteral("]")) -> subIn type() ;
}

flow OpPortSpc {
  [ParserData]-> opPortSpc(ParseOptional) -> ;
  opPortSpc() semOut [ParserData]-> (CreateOpPortSpc) -> semIn opPortSpc() ;
  opPortSpc() subOut [ParserData]-> portSpc(ParseAll) -> subIn opPortSpc() ;

  portSpc() semOut [ParserData]-> (CreatePortSpc) -> semIn portSpc() ;

  portSpc() subOut.0 [ParserData]-> (Port) -> subIn.0 portSpc() ;
  portSpc() subOut.1 [ParserData]-> (ParseSpace(false)) -> subIn.1 portSpc() ;
}

flow OpPort {
  [ParserData]-> opPort(ParseOptional) -> ;
  opPort() semOut [ParserData]-> (CreateOpPort) -> semIn opPort() ;
  opPort() subOut [ParserData]-> (Port) -> subIn opPort() ;
}

flow Port {
  [ParserData]-> port(ParseAll) -> ;
  port() semOut [ParserData]-> (CreatePort) -> semIn port() ;

  port() subOut.0 [ParserData]-> portName(SmallIdent) -> subIn.0 port() ;
  port() subOut.1 [ParserData]-> opPortNum(ParseOptional) -> subIn.1 port() ;

  opPortNum() subOut [ParserData]-> portNum(ParseAll) -> subIn opPortNum() ;
  portNum() semOut [ParserData]-> (CreatePortNum) -> semIn portNum() ;

  portNum() subOut.0 [ParserData]-> dot(ParseLiteral(".")) -> subIn.0 portNum() ;
  portNum() subOut.1 [ParserData]-> num(ParseNatural) -> subIn.1 portNum() ;
}


// -------------------------------------------------------------------------
// Utility like parser flows
//

flow SmallIdent {
  [ParserData]-> (ParseRegex("[a-z][a-zA-Z0-9]*")) -> ;
}

flow BigIdent {
  [ParserData]-> (ParseRegex("[A-Z][a-zA-Z0-9]+")) -> ;
}

flow OpSpc {
  [ParserData]-> opSpc(ParseOptional) -> ;
  opSpc() subOut [ParserData]-> (ParseSpace(false)) -> subIn opSpc() ;
}

flow StatementEnd {
  [ParserData]-> stmtEnd(ParseAll) -> ;

  stmtEnd() subOut.0 [ParserData]-> (SpaceComment) -> subIn.0 stmtEnd() ;
  stmtEnd() subOut.1 [ParserData]-> (ParseLiteral(";")) -> subIn.1 stmtEnd() ;
  stmtEnd() subOut.2 [ParserData]-> (SpaceComment) -> subIn.2 stmtEnd() ;
}

flow SpaceComment {
  [ParserData]-> spcComs(ParseMultiple0) -> ;
  spcComs() subOut [ParserData]-> spcOrCom(ParseAlternatives) -> subIn spcComs() ;
  spcOrCom() subOut.0 [ParserData]-> (ParseSpace(true)) -> subIn.0 spcOrCom() ;
  spcOrCom() subOut.1 [ParserData]-> (ParseComment(ALL)) -> subIn.1 spcOrCom() ;
}

